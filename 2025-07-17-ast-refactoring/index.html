<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¼˜åŒ–åçš„ASTç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .editor-panel {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #eee;
        }

        .ast-panel {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
        }

        .editor {
            border: 2px solid #ddd;
            border-radius: 4px;
            padding: 16px;
            min-height: 400px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
            transition: border-color 0.2s ease;
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œï¼Œä½†æ›´çµæ´» */
            tab-size: 4; /* è®¾ç½® Tab ä¸º 4 ä¸ªç©ºæ ¼çš„å®½åº¦ */
        }

        .editor:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        .line {
            min-height: 21px;
            outline: none;
            position: relative;
        }

        .line:empty::before {
            content: '';
            display: inline-block;
            width: 1px;
            height: 21px;
        }

        .line.block {
            font-weight: 500;
            color: #2c3e50;
        }

        .line.continue {
            color: #7f8c8d;
            font-style: italic;
        }

        .line.paragraph {
            color: #34495e;
        }

        .controls {
            margin-bottom: 16px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .ast-output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 16px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            line-height: 1.4;
            overflow-y: auto;
            max-height: 400px;
            white-space: pre-wrap;
        }

        .stats {
            margin-top: 16px;
            padding: 12px;
            background: #ecf0f1;
            border-radius: 4px;
            font-size: 12px;
            color: #7f8c8d;
        }

        .help {
            margin-top: 16px;
            padding: 12px;
            background: #e8f5e8;
            border-radius: 4px;
            font-size: 12px;
            color: #27ae60;
        }

        .help ul {
            list-style: none;
            padding-left: 0;
        }

        .help li {
            margin-bottom: 4px;
        }

        .help kbd {
            background: #34495e;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ä¼˜åŒ–åçš„ASTç¼–è¾‘å™¨</h1>
            <p>æ”¯æŒå±‚çº§ç¼©è¿›çš„æ™ºèƒ½æ–‡æœ¬ç¼–è¾‘å™¨ - è¾“å…¥"-"è‡ªåŠ¨è½¬æ¢ä¸ºå—èŠ‚ç‚¹</p>
        </div>
        
        <div class="main-content">
            <div class="editor-panel">
                <div class="controls">
                    <button class="btn btn-primary" onclick="astManager.renderAST()">æ›´æ–°AST</button>
                    <button class="btn btn-secondary" onclick="editorManager.initEditor()">åˆå§‹åŒ–ç¼–è¾‘å™¨ï¼Œåˆ›å»ºç©ºç™½è¡Œ</button>
                    <button class="btn btn-secondary" onclick="editorManager.loadSample()">åŠ è½½ç¤ºä¾‹</button>
                </div>
                
                <div id="editor" class="editor" contenteditable="true" spellcheck="false"></div>
                
                <div class="help">
                    <h4>å¿«æ·é”®è¯´æ˜</h4>
                    <ul>
                        <li><kbd>Enter</kbd> æ–°å»ºåŒçº§èŠ‚ç‚¹</li>
                        <li><kbd>Shift+Enter</kbd> æ–°å»ºç»§ç»­èŠ‚ç‚¹</li>
                        <li><kbd>Tab</kbd> å¢åŠ ç¼©è¿›</li>
                        <li><kbd>Shift+Tab</kbd> å‡å°‘ç¼©è¿›</li>
                        <li><kbd>-</kbd> å¼€å¤´åˆ›å»ºå—èŠ‚ç‚¹ (æ”¯æŒè‡ªåŠ¨è½¬æ¢)</li>
                    </ul>
                </div>
            </div>
            
            <div class="ast-panel">
                <h3>ASTè¾“å‡º</h3>
                <div id="astOutput" class="ast-output"></div>
                <div id="stats" class="stats"></div>
            </div>
        </div>
    </div>

    <script>
        // å¸¸é‡å®šä¹‰
        const NODE_TYPES = {
            BLOCK: 'block',
            CONTINUE: 'continue',
            PARAGRAPH: 'paragraph'
        };

        const INDENT_CHAR = '\t';
        const BLOCK_PREFIX = '- ';
        const CONTINUE_PREFIX = '  ';

        // å·¥å…·å‡½æ•°
        const Utils = {
            // ç”Ÿæˆå”¯ä¸€ID
            generateId: () => crypto.randomUUID(),
            
            // è·å–ç¼©è¿›çº§åˆ«
            getIndentLevel: (text) => {
                const match = text.match(/^(\t*)/);
                return match ? match[1].length : 0;
            },
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå—èŠ‚ç‚¹
            isBlockLine: (text) => {
                const match = text.match(/^(\t*)- /);
                return match ? match[1].length : null;
            },
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºç»§ç»­èŠ‚ç‚¹
            isContinueLine: (text) => {
                const match = text.match(/^(\t*)(?!-)/);
                // å¦‚æœæ˜¯ç©ºæ ¼ç¼©è¿›ï¼Œåˆ™è¿”å› false
                if (match && match[1].length > 0) {
                    return match[1].length;
                } else {
                    return null;
                }
            },

            continueLineLevel: (text) => {
                const match = text.match(/^(\t*)(?!-)/);
                return match ? match[1].length : null;
            },
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºç©ºæ ¼ç¼©è¿›
            hasSpaceIndent: (text) => {
                const match = text.match(/^( +)/);
                return match ? match[1].length : null;
            },
            
            // é˜²æŠ–å‡½æ•°
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
            
            // è®¾ç½®å…‰æ ‡åˆ°æœ«å°¾
            setCaretToEnd : function(line) {
                const range = document.createRange();
                const selection = window.getSelection();

                // å‡è®¾ line é‡Œåªæœ‰ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹
                const textNode = line.firstChild || line;
                const offset = textNode.textContent.length;

                range.setStart(textNode, offset);
                range.collapse(true); // å…‰æ ‡è€Œä¸æ˜¯é€‰ä¸­

                selection.removeAllRanges();
                selection.addRange(range);
            },

            /**
             * ä»ä¸€ä¸ªé€‰åŒº Range å¯¹è±¡ä¸­ï¼Œæ‰¾åˆ°å½“å‰è¡Œçš„ DOM å…ƒç´ 
             * å‡è®¾æ¯ä¸€è¡Œéƒ½æœ‰ data-id å±æ€§æ ‡è¯†
             * @param {Range} range
             * @returns {HTMLElement | null}
             */
            getLineElementFromRange(range) {
                if (!range || !range.startContainer) return null;

                const startNode = range.startContainer;

                // å¦‚æœ startNode æ˜¯å…ƒç´ èŠ‚ç‚¹ï¼Œå¯ä»¥ç›´æ¥å°è¯• .closest()
                if (startNode.nodeType === Node.ELEMENT_NODE) {
                return startNode.closest('[data-id]');
                }

                // å¦‚æœæ˜¯æ–‡æœ¬èŠ‚ç‚¹ï¼ˆå¸¸è§æƒ…å†µï¼‰ï¼Œä»å…¶çˆ¶å…ƒç´ å¼€å§‹æ‰¾
                if (startNode.nodeType === Node.TEXT_NODE && startNode.parentElement) {
                return startNode.parentElement.closest('[data-id]');
                }

                return null;
            },


        };

        // ASTèŠ‚ç‚¹ç±»
        class ASTNode {
            constructor({ id, styleType, type, content, indentLevel = 0 }) {
                this.id = id;
                this.type = type;
                this.styleType = styleType; // æ ·å¼ç±»å‹
                this.content = content;
                this.indentLevel = indentLevel;
                this.children = [];
                this.continueChildren = [];
                this.parent = null;
            }
            
            // æ·»åŠ å­èŠ‚ç‚¹
            addChild(node) {
                node.parent = this;
                this.children.push(node);
            }
            
            // åœ¨æŸä¸ªä½ç½®æ’å…¥å­èŠ‚ç‚¹
            InserChildrentNode(node, index) {
                node.parent = this;
                if (index < 0 || index > this.children.length) {
                    throw new Error('Index out of bounds');
                }
                this.children.splice(index, 0, node);
            }
            
            // æ·»åŠ ç»§ç»­èŠ‚ç‚¹
            addContinue(node) {
                node.parent = this;
                this.continueChildren.push(node);
            }
            
            // åœ¨æŸä¸ªä½ç½®æ’å…¥ç»§ç»­èŠ‚ç‚¹
            InsertContinueNode(node, index) {
                node.parent = this;
                if (index < 0 || index > this.continueChildren.length) {
                    throw new Error('Index out of bounds');
                }
                this.continueChildren.splice(index, 0, node);
            }
            
            // ç§»é™¤èŠ‚ç‚¹
            remove() {
                if (this.parent) {
                    const parentChildren = this.parent.children;
                    const parentContinues = this.parent.continueChildren;
                    
                    let index = parentChildren.indexOf(this);
                    if (index > -1) {
                        parentChildren.splice(index, 1);
                    } else {
                        index = parentContinues.indexOf(this);
                        if (index > -1) {
                            parentContinues.splice(index, 1);
                        }
                    }
                }
            }
            
            // è½¬æ¢ä¸ºJSON
            toJSON() {
                const result = {
                    id: this.id,
                    type: this.type,
                    styleType: this.styleType,
                    content: this.content,
                    indentLevel: this.indentLevel
                };

                if (this.continueChildren.length > 0) {
                    result.continueChildren = this.continueChildren.map(child => child.toJSON());
                }
                
                if (this.children.length > 0) {
                    result.children = this.children.map(child => child.toJSON());
                }
                
                return result;
            }
        }

        // ASTç®¡ç†å™¨
        class ASTManager {
            constructor() {
                this.root = [];
                this.nodeMap = new Map();
                this.indentStack = [];
            }
            
            clearAll(){
                this.clearNodeMap();
                this.clearRoot();
                this.clearIndentStack();
            }
            
            // æ¸…ç©ºAST
            clearNodeMap() {
                this.nodeMap.clear();
            }
            
            clearRoot() {
                this.root = [];
            }
            
            clearIndentStack() {
                this.indentStack = [];
                this.indentStack.length = 0;
            }
            
            // åˆ›å»ºèŠ‚ç‚¹
            createNode({ id, styleType, type, content, indentLevel }) {
                const node = new ASTNode({ id, styleType, type, content, indentLevel });
                this.nodeMap.set(id, node);
                return node;
            }
            
            // tab ç¼©è¿›æˆ–åç¼©è¿› æ¨¡å¼ä¸‹ï¼Œå‘ AST ä¸­æ’å…¥èŠ‚ç‚¹
            InsertNodeByTab(node){
                const { id, styleType, type, content, indentLevel } = node;
                if (type === NODE_TYPES.CONTINUE) {
                    this.handleContinueNodeByTab(indentLevel, content, id);
                } else if( type === NODE_TYPES.PARAGRAPH){
                    this.handleParagraphNodeByTab(NODE_TYPES.PARAGRAPH, NODE_TYPES.PARAGRAPH, indentLevel, content, id);
                } else if (type === NODE_TYPES.BLOCK) {
                    this.handleBlockNodeByTab(indentLevel, content, id);
                }
            }
            
            convertNodeType(id, newType, newStyleType, content) {
                const node = this.nodeMap.get(id);
                if (!node) {
                    console.error(`Node with id ${id} not found`);
                    return false;
                }
                
                // æ›´æ–°èŠ‚ç‚¹ç±»å‹å’Œæ ·å¼
                node.type = newType;
                node.styleType = newStyleType;
                node.content = content;
                
                // æ›´æ–°ç¼©è¿›çº§åˆ«
                node.indentLevel = Utils.getIndentLevel(content);
                
                // æ›´æ–°èŠ‚ç‚¹åœ¨ AST ä¸­çš„ä½ç½®
                // this.updateNodeInAST(node);
                
                return true;
            }
            
            // ä½¿ç”¨ enter é”®æ’å…¥èŠ‚ç‚¹
            enterInsertNode(e, frontAstNodeId, toInsertLineId, initialContent, indentLevel, frontLineAstNodeType) {
                // const toInsertLineId = toInsertLine.dataset.id
                if ((e.shiftKey && frontLineAstNodeType === NODE_TYPES.BLOCK) || frontLineAstNodeType === NODE_TYPES.CONTINUE) {
                    // åœ¨ AST ä¸­æ’å…¥ continue èŠ‚ç‚¹
                    this.enterInsertAstContinueNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel});
                } else if (frontLineAstNodeType === NODE_TYPES.PARAGRAPH) {
                    // åœ¨ AST ä¸­æ’å…¥æ®µè½èŠ‚ç‚¹
                    this.enterInsertAstParagraphNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel});
                } else if(frontLineAstNodeType === NODE_TYPES.BLOCK) {
                    // âœ… å¢é‡æ’å…¥ AST
                    this.enterInsertAstBlockNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel});
                }
            }

            enterInsertAstContinueNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel}) {
                let continueIndex = 0;
                const frontAstNode = this.nodeMap.get(frontAstNodeId);
                // å¦‚æœå½“å‰è¾“å…¥ shift+enter çš„è¡Œæ˜¯ continue èŠ‚ç‚¹ï¼Œåœ¨ idmapè·å–å…¶æ‰€å±çš„çˆ¶èŠ‚ç‚¹, å¦åˆ™å°±æ˜¯å½“å‰èŠ‚ç‚¹
                let parentAstNode = null;
                if (frontAstNode.type === NODE_TYPES.BLOCK){
                    parentAstNode = frontAstNode;
                } else {
                    parentAstNode = frontAstNode.parent;
                    if (!parentAstNode) {
                        console.error("parentAstNode, å½“å‰è¡Œæœªæ‰¾åˆ°å¯¹åº”çš„ AST çˆ¶èŠ‚ç‚¹");
                        return;
                    }
                }
                // è·å–å³å°†æ’å…¥çš„ continue èŠ‚ç‚¹åœ¨ parentAstNode.continueChildren ä¸­çš„ç´¢å¼•
                const toInsertIndex = parentAstNode.continueChildren.indexOf(frontAstNode) + 1;
                // }
                const node = this.createNode({
                    id: toInsertLineId,
                    styleType:NODE_TYPES.CONTINUE,
                    type:NODE_TYPES.CONTINUE,
                    content: initialContent,
                    indentLevel
                });
                parentAstNode.InsertContinueNode(node, toInsertIndex);
            }

            enterInsertAstParagraphNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel, styleType, type}) {
                if (!frontAstNodeId) {
                    console.error("frontAstNodeId, å½“å‰è¡Œæœªæ‰¾åˆ°å¯¹åº”çš„ AST èŠ‚ç‚¹");
                    return;
                }
                const node = this.createNode({
                    id: toInsertLineId,
                    styleType: styleType || NODE_TYPES.PARAGRAPH,
                    type: type || NODE_TYPES.PARAGRAPH,
                    content: initialContent,
                    indentLevel}
                )
                // è·å–å‰é¢è¡Œçš„AstèŠ‚ç‚¹
                const frontAstNode = this.nodeMap.get(frontAstNodeId);
                // è·å–åœ¨ astRoot ä¸­çš„ç´¢å¼•
                const toInsertAstRootIndex = this.root.findIndex(n => n.id === frontAstNode.id);
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç´¢å¼•ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹
                if (toInsertAstRootIndex ===  -1) {
                    console.warn("å½“å‰ AST èŠ‚ç‚¹æœªæ‰¾åˆ°åœ¨ astRoot ä¸­çš„ç´¢å¼•");
                    return;
                }
                // åœ¨ astRoot ä¸­æ’å…¥èŠ‚ç‚¹
                this.root.splice(toInsertAstRootIndex + 1, 0, node);
            }

            enterInsertAstBlockNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel}) {
                // è·å–å½“å‰AstèŠ‚ç‚¹
                const frontAstNode = this.nodeMap.get(frontAstNodeId);
                if (!frontAstNode) {
                    console.error("frontAstNode, å½“å‰è¡Œæœªæ‰¾åˆ°å¯¹åº”çš„ AST èŠ‚ç‚¹");
                    return;
                }
                const node = this.createNode({
                    id: toInsertLineId,
                    styleType: NODE_TYPES.BLOCK,
                    type: NODE_TYPES.BLOCK,
                    content: initialContent,
                    indentLevel}
                )

                let tempChildren = frontAstNode.children || [];
                let tempContinueChildren = frontAstNode.continueChildren || [];
                if (tempChildren.length > 0 || tempContinueChildren.length > 0) {
                    // å°† tempChildren å’Œ tempContinueChildren ä¸­çš„èŠ‚ç‚¹ä½œä¸ºtoInsertLineId å¯¹åº”èŠ‚ç‚¹çš„ children ä¸ continueChildren, å¹¶ä¸”è¦è°ƒæ•´ children ä¸ continueChildren ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„ parent
                    node.children = tempChildren;
                    node.continueChildren = tempContinueChildren;
                    // æ›´æ–°æ¯ä¸ªå­èŠ‚ç‚¹çš„ parent
                    tempChildren.forEach(child => {
                        child.parent = node;
                    });
                    tempContinueChildren.forEach(child => {
                        child.parent = node;
                    });
                    
                    // åˆ é™¤ frontAstNode ä¸­çš„ children å’Œ continueChildren
                    frontAstNode.children = [];
                    frontAstNode.continueChildren = [];
                } 

                const astNodeParent = frontAstNode?.parent;
                if (!astNodeParent) {
                    // è·å–åœ¨ this.root ä¸­çš„ç´¢å¼•
                    const toInsertIndex = this.root.findIndex(n => n.id === frontAstNode.id);
                    if (toInsertIndex === -1) {
                        console.error("å½“å‰ Block AST èŠ‚ç‚¹æœªæ‰¾åˆ°åœ¨ astRoot ä¸­çš„ç´¢å¼•");
                        return;
                    }
                    // åœ¨ astRoot ä¸­æ’å…¥èŠ‚ç‚¹
                    this.root.splice(toInsertIndex + 1, 0, node);
                } else {
                    // è·å– frontAstNode åœ¨ astNodeParent.children ä¸­çš„ç´¢å¼•
                    const toInsertIndex = astNodeParent.children.indexOf(frontAstNode)
                    astNodeParent.InserChildrentNode(node, toInsertIndex + 1);
                }
            }
            
            // æ’å…¥èŠ‚ç‚¹
            insertNode(content, id) {
                const indentLevel = Utils.getIndentLevel(content);
                const blockLevel = Utils.isBlockLine(content);
                const continueLevel = Utils.continueLineLevel(content);
                const spaceIndent = Utils.hasSpaceIndent(content);
                
                let type = NODE_TYPES.PARAGRAPH;
                
                // åˆ¤æ–­èŠ‚ç‚¹ç±»å‹
                if (blockLevel !== null) {
                    type = NODE_TYPES.BLOCK;
                } else if (this.isContinueLine(indentLevel, continueLevel, spaceIndent)) {
                    type = NODE_TYPES.CONTINUE;
                }
                
                const node = this.createNode({ id, styleType: type, type, content, indentLevel });
                
                // æ ¹æ®ç±»å‹å¤„ç†èŠ‚ç‚¹
                switch (type) {
                    case NODE_TYPES.BLOCK:
                        this.handleBlockNode(node, indentLevel);
                        break;
                    case NODE_TYPES.CONTINUE:
                        this.handleContinueNode(node, indentLevel);
                        break;
                    case NODE_TYPES.PARAGRAPH:
                        this.handleParagraphNode(node);
                        break;
                }
                
                return node;
            }
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºç»§ç»­è¡Œ
            isContinueLine(indentLevel, continueLevel, spaceIndent) {
                const lastStackNode = this.indentStack[this.indentStack.length - 1];
                return (continueLevel === this.indentStack.length - 1) || 
                       (lastStackNode && spaceIndent > 0);
            }

            // å¤„ç† å—èŠ‚ç‚¹ åœ¨ tab  ç¼©è¿›æˆ–åç¼©è¿› æ¨¡å¼ä¸‹
            handleBlockNodeByTab(indentLevel, content, id) {
                const node = this.createNode({ id, styleType: NODE_TYPES.BLOCK, type: NODE_TYPES.BLOCK, content, indentLevel });
                const parent = indentLevel > 0 ? this.indentStack[indentLevel - 1] : null;
                const closeParent = this.indentStack.length > 0 ? this.indentStack[this.indentStack.length - 1] : null

                if (parent) {
                    parent.addChild(node)
                    this.indentStack[indentLevel] = node;
                    this.indentStack.length = indentLevel + 1;
                } else if (closeParent !== null && closeParent.type === NODE_TYPES.BLOCK && indentLevel - 1 > closeParent.indentLevel) {
                    node.styleType = NODE_TYPES.CONTINUE
                    closeParent.addContinue(node);
                } else if (indentLevel === 0){
                    this.root.push(node);
                    this.indentStack[0] = node;
                    this.indentStack.length = 1;
                } else {
                    console.warn("æ— æ³•æ‰¾åˆ° block èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œè¯·æ£€æŸ¥ç¼©è¿›æ ¼å¼");
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ï¼Œå¯èƒ½æ˜¯å› ä¸ºç¼©è¿›æ ¼å¼ä¸æ­£ç¡®ï¼Œç›´æ¥æ’å…¥ä¸€ä¸ªæ®µè½èŠ‚ç‚¹
                    this.handleParagraphNodeByTab(NODE_TYPES.BLOCK, NODE_TYPES.PARAGRAPH, indentLevel, content,  id);
                }
            }
            
            // å¤„ç†å—èŠ‚ç‚¹
            handleBlockNode(node, indentLevel) {
                const parent = indentLevel > 0 ? this.indentStack[indentLevel - 1] : null;
                
                if (parent) {
                    parent.addChild(node);
                } else if (indentLevel === 0) {
                    this.root.push(node);
                } else {
                    // å¤„ç†ç¼©è¿›é”™è¯¯
                    this.root.push(node);
                    console.warn('ç¼©è¿›çº§åˆ«ä¸åŒ¹é…ï¼Œå·²æ’å…¥åˆ°æ ¹çº§åˆ«');
                }
                
                // æ›´æ–°ç¼©è¿›æ ˆ
                this.indentStack[indentLevel] = node;
                this.indentStack.length = indentLevel + 1;
            }
            
            // å¤„ç†ç»§ç»­èŠ‚ç‚¹
            handleContinueNode(node, indentLevel) {
                const parent = this.indentStack[indentLevel];
                
                if (parent && parent.type === NODE_TYPES.BLOCK) {
                    parent.addContinue(node);
                } else {
                    // è½¬ä¸ºæ®µè½èŠ‚ç‚¹
                    node.type = NODE_TYPES.PARAGRAPH;
                    this.handleParagraphNode(node);
                }
            }

            handleContinueNodeByTab(indentLevel, content, id) {
                const parent = this.indentStack[indentLevel];
                const closeParent = this.indentStack.length > 0 ? this.indentStack[this.indentStack.length - 1] : null;
                const spaceCount = closeParent !== null ? Utils.hasSpaceIndent(content) : null;
                // å¦‚æœæ˜¯ continue èŠ‚ç‚¹ï¼Œä¸”ä¸Šä¸€ä¸ªèŠ‚ç‚¹æ˜¯ block èŠ‚ç‚¹ï¼Œ
                // ä¸” continueIndent å¤§äº 0 æˆ–è€… spaceCount å¤§äº 0
                // åˆ™å°† continue èŠ‚ç‚¹æ·»åŠ åˆ° block èŠ‚ç‚¹çš„ continueChildren ä¸­
                if (closeParent && closeParent.type === NODE_TYPES.BLOCK && (indentLevel > 0 || spaceCount > 0) ) {
                    // åˆ›å»º Node çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿä¼šæ›´æ–° nodeMap
                    const node = this.createNode({ id, styleType: NODE_TYPES.CONTINUE, type: NODE_TYPES.CONTINUE, content, indentLevel });
                    closeParent.addContinue(node);
                } else {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ï¼Œå¯èƒ½æ˜¯å› ä¸ºç¼©è¿›æ ¼å¼ä¸æ­£ç¡®ï¼Œç›´æ¥æ’å…¥ä¸€ä¸ªæ®µè½èŠ‚ç‚¹
                    this.handleParagraphNodeByTab(NODE_TYPES.PARAGRAPH, NODE_TYPES.PARAGRAPH, indentLevel, content, id);
                    console.warn("æ— æ³•æ‰¾åˆ° continue èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œè¯·æ£€æŸ¥ç¼©è¿›æ ¼å¼");
                    return;
                }
            }
            
            // å¤„ç†æ®µè½èŠ‚ç‚¹
            handleParagraphNode(node) {
                this.root.push(node);
                this.indentStack = [];
            }
            
            handleParagraphNodeByTab(type, styleType, indentLevel, content, id) {
                // åˆ›å»º Node çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿä¼šæ›´æ–° nodeMap
                const node = this.createNode({ id, styleType, type, content, indentLevel });
                this.root.push(node);
                this.indentStack = [];
            }
            
            // æ›´æ–°èŠ‚ç‚¹å†…å®¹
            updateNodeContent(id, content) {
                const node = this.nodeMap.get(id);
                if (node) {
                    node.content = content;
                }
            }
            
            // åˆ é™¤èŠ‚ç‚¹
            deleteNode(id) {
                const node = this.nodeMap.get(id);
                if (node) {
                    node.remove();
                    this.nodeMap.delete(id);
                }
            }
            
            // é‡å»ºAST
            rebuild() {
                this.clearNodeMap();
                this.clearIndentStack();
                
                // è·å–æ‰å¹³åŒ–çš„èŠ‚ç‚¹åˆ—è¡¨
                const flatNodes = this.flattenNodes(this.root);
                // æ¸…ç©ºæ ¹èŠ‚ç‚¹
                this.clearRoot();
                // é‡æ–°æ„å»º
                flatNodes.forEach(node => {
                    this.InsertNodeByTab(node);
                });
            }
            
            // é‡å»ºAST
            rebuildWhenMutationsLine(editor) {
                
                // è·å–æ‰å¹³åŒ–çš„èŠ‚ç‚¹åˆ—è¡¨
                const flatNodes = this.flattenNodesFromEditor(editor);
                // // æ¸…ç©ºèŠ‚ç‚¹æ˜ å°„
                // this.clearNodeMap();
                // // æ¸…ç©ºæ ¹èŠ‚ç‚¹
                // this.clearRoot();
                // this.clearIndentStack();
                this.clearAll();
                // é‡æ–°æ„å»º
                flatNodes.forEach(node => {
                    this.insertNode(node.content, node.id);
                });
            }

            // æ‰å¹³åŒ–èŠ‚ç‚¹
            flattenNodes(nodes) {
                const result = [];
                
                function flatten(nodeList) {
                    nodeList.forEach(node => {
                        result.push(node);
                        if (node.continueChildren.length > 0) {
                            flatten(node.continueChildren);
                        }
                        if (node.children.length > 0) {
                            flatten(node.children);
                        }
                    });
                }
                
                flatten(nodes);
                return result;
            }

            // é€šè¿‡ editor æŒ‰é¡ºåºè·å–æ‰€æœ‰çš„ lineï¼Œé€šè¿‡ editor children çš„æ–¹å¼è·å–
            flattenNodesFromEditor(editor) {
                const lines = Array.from(editor.children);
                // é€šè¿‡ nodeMap è·å– AST èŠ‚ç‚¹
                return lines.map(line => {
                    const id = line.dataset.id;
                    const node = this.nodeMap.get(id);
                    if (!node) {
                        // console.warn(`æœªæ‰¾åˆ°å¯¹åº”çš„ AST èŠ‚ç‚¹: ${id}`);
                        return this.createNode({
                            id,
                            styleType: null,
                            type: null,
                            content: line.textContent || '',
                            indentLevel: null
                        });
                    }
                    return node

                });
            }
            
            // æ¸²æŸ“AST
            renderAST() {
                const output = document.getElementById('astOutput');
                const stats = document.getElementById('stats');
                
                const astData = this.root.map(node => node.toJSON());
                output.textContent = JSON.stringify(astData, null, 2);
                
                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                const totalNodes = this.nodeMap.size;
                const blockNodes = Array.from(this.nodeMap.values()).filter(n => n.type === NODE_TYPES.BLOCK).length;
                const continueNodes = Array.from(this.nodeMap.values()).filter(n => n.type === NODE_TYPES.CONTINUE).length;
                const paragraphNodes = Array.from(this.nodeMap.values()).filter(n => n.type === NODE_TYPES.PARAGRAPH).length;
                
                stats.innerHTML = `
                    <strong>ç»Ÿè®¡ä¿¡æ¯:</strong>
                    æ€»èŠ‚ç‚¹: ${totalNodes} | 
                    å—èŠ‚ç‚¹: ${blockNodes} | 
                    ç»§ç»­èŠ‚ç‚¹: ${continueNodes} | 
                    æ®µè½èŠ‚ç‚¹: ${paragraphNodes}
                `;
            }
            
            // è·å–èŠ‚ç‚¹
            getNode(id) {
                return this.nodeMap.get(id);
            }
        }

        // ç¼–è¾‘å™¨ç®¡ç†å™¨
        class EditorManager {
            constructor(editorElement, astManager) {
                this.editor = editorElement;
                this.astManager = astManager;
                this.setupEventListeners();
            }
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners() {
                this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
                this.editor.addEventListener('input', Utils.debounce(this.handleInput.bind(this), 200));
            }
            
            // å¤„ç†é”®ç›˜äº‹ä»¶
            handleKeydown(e) {
                switch (e.key) {
                    case 'Enter':
                        this.handleEnter(e);
                        break;
                    case 'Tab':
                        this.handleTab(e);
                        break;
                }
            }
            
            // å¤„ç†å›è½¦é”®
            handleEnter(e) {
                e.preventDefault();
                
                const currentLine = this.getCurrentLine();
                if (!currentLine) return;
                
                const currentContent = currentLine.textContent || '';
                const currentNode = this.astManager.getNode(currentLine.dataset.id);
                
                if (!currentNode) return;
                
                const indentLevel = Utils.getIndentLevel(currentContent);
                const toInsertLineId = Utils.generateId();
                
                // ç¡®å®šæ–°è¡Œçš„åˆå§‹å†…å®¹
                let initialContent = INDENT_CHAR.repeat(indentLevel);
                
                if ((e.shiftKey && currentNode.type === NODE_TYPES.BLOCK) || currentNode.type === NODE_TYPES.CONTINUE) {
                    initialContent += CONTINUE_PREFIX;
                } else if (currentNode.type === NODE_TYPES.PARAGRAPH) {
                    // æ®µè½è¡Œä¿æŒç›¸åŒç¼©è¿›
                } else {
                    initialContent += BLOCK_PREFIX;
                }
                
                // åˆ›å»ºæ–°è¡Œ
                const newLine = this.createLine(initialContent, toInsertLineId);
                this.insertLineAfter(currentLine, newLine);
                Utils.setCaretToEnd(newLine);
                
                // æ›´æ–°AST
                const frontAstNodeId = currentNode.id;
                this.astManager.enterInsertNode(e, frontAstNodeId, toInsertLineId, initialContent, indentLevel, 
                    currentNode.type);
                this.astManager.renderAST();
            }
            
            // å¤„ç†Tabé”®
            handleTab(e) {
                e.preventDefault();
                const isShift = e.shiftKey;
                const selection = window.getSelection();
                const range = selection.getRangeAt(0);

                // è·å–é€‰ä¸­æ‰€æœ‰è¡Œï¼ˆå·²æ’åºï¼‰
                const lines = this.getSelectedLines();
                if (!lines.length) return;

                const isSingleLine = lines.length === 1;

                // ç¼“å­˜å…‰æ ‡ä¿¡æ¯
                const anchorOffset = range.startOffset;
                const focusOffset = range.endOffset;

                // ç¼“å­˜åŸå§‹çš„é”šç‚¹å’Œç„¦ç‚¹è¡Œ
                const originalAnchorLine = lines[0];
                const originalFocusLine = lines[lines.length - 1];

                // æ‰§è¡Œç¼©è¿›é€»è¾‘
                lines.forEach(line => {
                    const node = this.astManager.getNode(line.dataset.id);
                    if (!node) return;

                    let text = line.textContent;
                    if (isShift) {
                        if (text.startsWith(INDENT_CHAR)) {
                            text = text.slice(1);
                            node.indentLevel = Math.max(0, node.indentLevel - 1);
                        }
                    } else {
                        text = INDENT_CHAR + text;
                        node.indentLevel += 1;
                    }

                    line.textContent = text;
                    node.content = text;

                    if (node.indentLevel > 0 && node.type === NODE_TYPES.PARAGRAPH) {
                        const continueLevel = Utils.continueLineLevel(text);
                        node.type = continueLevel !== null ? NODE_TYPES.CONTINUE : NODE_TYPES.BLOCK;
                    }
                });

                // æ–°çš„é€‰åŒºæ¢å¤
                const newAnchorNode = originalAnchorLine.firstChild;
                const newFocusNode = originalFocusLine.firstChild;

                if (newAnchorNode && newFocusNode) {
                    const newRange = document.createRange();

                    if (isSingleLine) {
                        // å•è¡Œï¼šå…‰æ ‡éšç€ç¼©è¿›ç§»åŠ¨
                        const delta = isShift ? -1 : 1;
                        const adjustedAnchorOffset = Math.max(0, anchorOffset + delta);
                        const adjustedFocusOffset = Math.max(0, focusOffset + delta);

                        newRange.setStart(newAnchorNode, Math.min(adjustedAnchorOffset, newAnchorNode.length));
                        newRange.setEnd(newFocusNode, Math.min(adjustedFocusOffset, newFocusNode.length));
                    } else {
                        // å¤šè¡Œï¼šä¿æŒæ•´å—é€‰åŒºï¼Œä¸è¦åç§»
                        newRange.setStart(newAnchorNode, 0);
                        newRange.setEnd(newFocusNode, newFocusNode.length);
                    }

                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }

                this.editor.focus();
                this.astManager.rebuild();
                this.astManager.renderAST();

            }

            // å¤„ç†è¾“å…¥äº‹ä»¶ - å¢å¼ºç‰ˆï¼Œæ”¯æŒè‡ªåŠ¨è½¬æ¢ä¸ºå—èŠ‚ç‚¹
            handleInput(e) {
                const line = this.getCurrentLine();
                if (!line) return;
                
                const id = line.dataset.id;
                const content = line.textContent || '';
                const currentNode = this.astManager.getNode(id);
                
                if (!currentNode) return;
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦è½¬æ¢èŠ‚ç‚¹ç±»å‹
                this.checkAndConvertNodeType(line, currentNode, content);
                
                // æ›´æ–°ASTä¸­çš„èŠ‚ç‚¹å†…å®¹
                this.astManager.updateNodeContent(id, content);
                this.astManager.renderAST();
            }
            
            // æ£€æŸ¥å¹¶è½¬æ¢èŠ‚ç‚¹ç±»å‹
            checkAndConvertNodeType(line, currentNode, content) {
                const indentLevel = Utils.getIndentLevel(content);
                const isBlockLine = Utils.isBlockLine(content) !== null;
                const isContinueLine = Utils.isContinueLine(content) !== null && !isBlockLine;
                
                let newType = NODE_TYPES.PARAGRAPH;
                let newStyleType = NODE_TYPES.PARAGRAPH;
                
                // æ ¹æ®å†…å®¹ç¡®å®šæ–°çš„èŠ‚ç‚¹ç±»å‹
                if (isBlockLine) {
                    newType = NODE_TYPES.BLOCK;
                    newStyleType = NODE_TYPES.BLOCK;
                } else if (isContinueLine && this.hasBlockParent(currentNode)) {
                    newType = NODE_TYPES.CONTINUE;
                    newStyleType = NODE_TYPES.CONTINUE;
                } else {
                    newType = NODE_TYPES.PARAGRAPH;
                    newStyleType = NODE_TYPES.PARAGRAPH;
                }
                
                // å¦‚æœç±»å‹å‘ç”Ÿå˜åŒ–ï¼Œè¿›è¡Œè½¬æ¢
                if (currentNode.type !== newType) {
                    console.log(`è½¬æ¢èŠ‚ç‚¹ç±»å‹: ${currentNode.type} -> ${newType}`, { content, indentLevel });
                    
                    // è½¬æ¢ASTä¸­çš„èŠ‚ç‚¹ç±»å‹
                    const success = this.astManager.convertNodeType(currentNode.id, newType, newStyleType, content);
                    
                    if (success) {
                        // æ›´æ–°DOMå…ƒç´ çš„æ ·å¼ç±»
                        this.updateLineStyle(line, newStyleType);
                        
                        // å¦‚æœè½¬æ¢æˆåŠŸï¼Œé‡å»ºASTä»¥ç¡®ä¿ç»“æ„æ­£ç¡®
                        this.astManager.rebuild();
                    }
                } else {
                    // å³ä½¿ç±»å‹æ²¡æœ‰å˜åŒ–ï¼Œä¹Ÿè¦ç¡®ä¿æ ·å¼ç±»æ­£ç¡®
                    this.updateLineStyle(line, newStyleType);
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å—èŠ‚ç‚¹çˆ¶çº§
            hasBlockParent(currentNode) {
                return currentNode && currentNode.parent?.type === NODE_TYPES.BLOCK;
            }
            
            // æ›´æ–°è¡Œçš„æ ·å¼ç±»
            updateLineStyle(line, styleType) {
                // ç§»é™¤æ‰€æœ‰æ ·å¼ç±»
                line.classList.remove('block', 'continue', 'paragraph');
                
                // æ·»åŠ æ–°çš„æ ·å¼ç±»
                switch (styleType) {
                    case NODE_TYPES.BLOCK:
                        line.classList.add('block');
                        break;
                    case NODE_TYPES.CONTINUE:
                        line.classList.add('continue');
                        break;
                    case NODE_TYPES.PARAGRAPH:
                        line.classList.add('paragraph');
                        break;
                }
            }
            
            // åˆ›å»ºè¡Œå…ƒç´ 
            createLine(content = '', id = Utils.generateId()) {
                const div = document.createElement('div');
                div.className = 'line';
                // div.contentEditable = 'true';
                div.textContent = content;
                div.dataset.id = id;
                
                // æ ¹æ®å†…å®¹æ·»åŠ æ ·å¼ç±»
                if (Utils.isBlockLine(content) !== null) {
                    div.classList.add('block');
                } else if (Utils.isContinueLine(content) !== null) {
                    div.classList.add('continue');
                } else {
                    div.classList.add('paragraph');
                }
                return div;
            }
            
            // åœ¨æŒ‡å®šè¡Œåæ’å…¥æ–°è¡Œ
            insertLineAfter(currentLine, newLine) {
                const nextLine = currentLine.nextSibling;
                if (nextLine) {
                    this.editor.insertBefore(newLine, nextLine);
                } else {
                    this.editor.appendChild(newLine);
                }
            }
            
            // è·å–å½“å‰è¡Œ
            getCurrentLine() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return null;
                
                let node = selection.anchorNode;
                if (node.nodeType === 3) node = node.parentNode;
                
                while (node && node !== this.editor && !node.classList.contains('line')) {
                    node = node.parentNode;
                }
                // æ²¡æœ‰å¿…è¦è¿”å› index
                // Array.from(editor.children).indexOf(node);
                return (node && node !== this.editor) ? node : null;
            }
            
            // è·å–é€‰ä¸­çš„è¡Œ
            // getSelectedLines() {
            //     const selection = window.getSelection();
            //     const range = selection.getRangeAt(0);
                
            //     return Array.from(this.editor.children).filter(line => {
            //         const lineRect = line.getBoundingClientRect();
            //         const rangeRect = range.getBoundingClientRect();
            //         return lineRect.bottom > rangeRect.top && lineRect.top < rangeRect.bottom;
            //     });
            // }

            // è·å–é€‰ä¸­çš„è¡Œï¼ˆæ”¯æŒå…‰æ ‡å’Œå¤šè¡Œé€‰ä¸­ï¼‰
            getSelectedLines() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return [];

                const range = selection.getRangeAt(0);

                // å¦‚æœæ˜¯æŠ˜å é€‰åŒºï¼ˆå…‰æ ‡ï¼‰
                if (range.collapsed) {
                    // å…‰æ ‡æ‰€åœ¨çš„ DOM èŠ‚ç‚¹
                    let node = range.startContainer;
                    // å¦‚æœå…‰æ ‡è½åœ¨æ–‡æœ¬èŠ‚ç‚¹é‡Œï¼Œæ‹¿å®ƒçš„çˆ¶å…ƒç´ 
                    if (node.nodeType === Node.TEXT_NODE) {
                        node = node.parentElement;
                    }
                    // æ‰¾åˆ°å±äº editor çš„ç›´æ¥å­å…ƒç´ ï¼ˆå³ä¸€è¡Œï¼‰
                    while (node && node.parentElement !== this.editor) {
                        node = node.parentElement;
                    }
                    return node ? [node] : [];
                }

                // å¦‚æœæ˜¯éæŠ˜å é€‰åŒºï¼ˆæœ‰é€‰ä¸­æ–‡å­—ï¼‰
                const rangeRect = range.getBoundingClientRect();
                return Array.from(this.editor.children).filter(line => {
                    const lineRect = line.getBoundingClientRect();
                    return lineRect.bottom > rangeRect.top && lineRect.top < rangeRect.bottom;
                });
            }

            
            // æ¸…ç©ºç¼–è¾‘å™¨
            clear() {
                this.editor.innerHTML = '';
                this.astManager.clearAll();
                this.astManager.renderAST();
            }
            // åˆå§‹åŒ–ç¼–è¾‘å™¨ï¼Œåˆ›å»ºç©ºç™½è¡Œ
            initEditor() {
                this.clear();
                const id = Utils.generateId();
                const content = "";
                const lineElement = this.createLine(content, id);
                this.editor.appendChild(lineElement);
                this.astManager.insertNode(content, id);
                this.astManager.renderAST();
            }
            
            // åŠ è½½ç¤ºä¾‹å†…å®¹
            loadSample() {
                const sampleLines = [
                    '- é¡¹ç›®ç®¡ç†',
                    '\t- ä»»åŠ¡åˆ†é…',
                    '\t\t- å¼€å‘ä»»åŠ¡',
                    '\t\t- æµ‹è¯•ä»»åŠ¡',
                    '\t- è¿›åº¦è·Ÿè¸ª',
                    '\t  å®šæœŸæ£€æŸ¥é¡¹ç›®è¿›åº¦',
                    '\t  åŠæ—¶è°ƒæ•´è®¡åˆ’',
                    '- ä»£ç ä¼˜åŒ–',
                    '\t- æ€§èƒ½ä¼˜åŒ–',
                    '\t- ä»£ç é‡æ„',
                    'è¿™æ˜¯ä¸€ä¸ªæ™®é€šæ®µè½',
                    'è¿™æ˜¯å¦ä¸€ä¸ªæ®µè½'
                ];
                
                this.clear();
                
                sampleLines.forEach(content => {
                    const id = Utils.generateId();
                    const lineElement = this.createLine(content, id);
                    this.editor.appendChild(lineElement);
                    this.astManager.insertNode(content, id);
                });
                
                this.astManager.renderAST();
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        const editor = document.getElementById('editor');
        const astManager = new ASTManager();
        const editorManager = new EditorManager(editor, astManager);

        // åˆ›å»º observer å®ä¾‹
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.removedNodes.length > 0) {
                    console.log('âš ï¸ æŸäº› .line è¢«åˆ é™¤:', mutation.removedNodes);
                    // ä» AST ä¸­åˆ é™¤å¯¹åº”çš„èŠ‚ç‚¹
                    astManager.rebuildWhenMutationsLine(editor);
                    astManager.renderAST();
                } else if (mutation.addedNodes.length > 0 && isUndoing === true) {
                    console.log('ğŸ”„ æŸäº› .line è¢«æ·»åŠ :', mutation.addedNodes);
                    // é‡æ–°æ„å»º AST
                    astManager.rebuildWhenMutationsLine(editor);
                    astManager.renderAST();
                }

            });
        });

        // å¼€å§‹ç›‘å¬ editor å†…éƒ¨å­èŠ‚ç‚¹çš„å¢åˆ 
        observer.observe(editor, {
            childList: true,      // ç›‘å¬å­å…ƒç´ å˜åŒ–
            subtree: false        // ä¸é€’å½’ç›‘å¬å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        });

        let isUndoing = false;

        // ç›‘å¬ beforeinput æ¥æ•æ‰æ˜¯å¦æ˜¯æ’¤é”€æ“ä½œ
        editor.addEventListener('beforeinput', (event) => {
            if (event.inputType === 'historyUndo') {
                isUndoing = true;
                // å»¶è¿Ÿæ¸…é™¤æ ‡å¿—ï¼Œé¿å…é”™è¿‡ observer çš„å¼‚æ­¥è§¦å‘
                setTimeout(() => {
                    isUndoing = false;
                }, 50);
            }
        });

        // åŠ è½½ç¤ºä¾‹å†…å®¹
        editorManager.loadSample();
    </script>
</body>
</html>