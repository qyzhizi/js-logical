<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>优化后的AST编辑器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .editor-panel {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #eee;
        }

        .ast-panel {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
        }

        .editor {
            border: 2px solid #ddd;
            border-radius: 4px;
            padding: 16px;
            min-height: 400px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
            transition: border-color 0.2s ease;
            white-space: pre-wrap; /* 保留换行，但更灵活 */
            tab-size: 4; /* 设置 Tab 为 4 个空格的宽度 */
        }

        .editor:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        .line {
            min-height: 21px;
            outline: none;
            position: relative;
        }

        .line:empty::before {
            content: '';
            display: inline-block;
            width: 1px;
            height: 21px;
        }

        .line.block {
            font-weight: 500;
            color: #2c3e50;
        }

        .line.continue {
            color: #7f8c8d;
            font-style: italic;
        }

        .line.paragraph {
            color: #34495e;
        }

        .controls {
            margin-bottom: 16px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .ast-output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 16px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            line-height: 1.4;
            overflow-y: auto;
            max-height: 400px;
            white-space: pre-wrap;
        }

        .stats {
            margin-top: 16px;
            padding: 12px;
            background: #ecf0f1;
            border-radius: 4px;
            font-size: 12px;
            color: #7f8c8d;
        }

        .help {
            margin-top: 16px;
            padding: 12px;
            background: #e8f5e8;
            border-radius: 4px;
            font-size: 12px;
            color: #27ae60;
        }

        .help ul {
            list-style: none;
            padding-left: 0;
        }

        .help li {
            margin-bottom: 4px;
        }

        .help kbd {
            background: #34495e;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>优化后的AST编辑器</h1>
            <p>支持层级缩进的智能文本编辑器 - 输入"-"自动转换为块节点</p>
        </div>
        
        <div class="main-content">
            <div class="editor-panel">
                <div class="controls">
                    <button class="btn btn-primary" onclick="astManager.renderAST()">更新AST</button>
                    <button class="btn btn-secondary" onclick="editorManager.initEditor()">初始化编辑器，创建空白行</button>
                    <button class="btn btn-secondary" onclick="editorManager.loadSample()">加载示例</button>
                </div>
                
                <div id="editor" class="editor" contenteditable="true" spellcheck="false"></div>
                
                <div class="help">
                    <h4>快捷键说明</h4>
                    <ul>
                        <li><kbd>Enter</kbd> 新建同级节点</li>
                        <li><kbd>Shift+Enter</kbd> 新建继续节点</li>
                        <li><kbd>Tab</kbd> 增加缩进</li>
                        <li><kbd>Shift+Tab</kbd> 减少缩进</li>
                        <li><kbd>-</kbd> 开头创建块节点 (支持自动转换)</li>
                    </ul>
                </div>
            </div>
            
            <div class="ast-panel">
                <h3>AST输出</h3>
                <div id="astOutput" class="ast-output"></div>
                <div id="stats" class="stats"></div>
            </div>
        </div>
    </div>

    <script>
        // 常量定义
        const NODE_TYPES = {
            BLOCK: 'block',
            CONTINUE: 'continue',
            PARAGRAPH: 'paragraph'
        };

        const INDENT_CHAR = '\t';
        const BLOCK_PREFIX = '- ';
        const CONTINUE_PREFIX = '  ';

        // 工具函数
        const Utils = {
            // 生成唯一ID
            generateId: () => crypto.randomUUID(),
            
            // 获取缩进级别
            getIndentLevel: (text) => {
                const match = text.match(/^(\t*)/);
                return match ? match[1].length : 0;
            },
            
            // 检查是否为块节点
            isBlockLine: (text) => {
                const match = text.match(/^(\t*)- /);
                return match ? match[1].length : null;
            },
            
            // 检查是否为继续节点
            isContinueLine: (text) => {
                const match = text.match(/^(\t*)(?!-)/);
                // 如果是空格缩进，则返回 false
                if (match && match[1].length > 0) {
                    return match[1].length;
                } else {
                    return null;
                }
            },

            continueLineLevel: (text) => {
                const match = text.match(/^(\t*)(?!-)/);
                return match ? match[1].length : null;
            },
            
            // 检查是否为空格缩进
            hasSpaceIndent: (text) => {
                const match = text.match(/^( +)/);
                return match ? match[1].length : null;
            },
            
            // 防抖函数
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
            
            // 设置光标到末尾
            setCaretToEnd : function(line) {
                const range = document.createRange();
                const selection = window.getSelection();

                // 假设 line 里只有一个文本节点
                const textNode = line.firstChild || line;
                const offset = textNode.textContent.length;

                range.setStart(textNode, offset);
                range.collapse(true); // 光标而不是选中

                selection.removeAllRanges();
                selection.addRange(range);
            },

            /**
             * 从一个选区 Range 对象中，找到当前行的 DOM 元素
             * 假设每一行都有 data-id 属性标识
             * @param {Range} range
             * @returns {HTMLElement | null}
             */
            getLineElementFromRange(range) {
                if (!range || !range.startContainer) return null;

                const startNode = range.startContainer;

                // 如果 startNode 是元素节点，可以直接尝试 .closest()
                if (startNode.nodeType === Node.ELEMENT_NODE) {
                return startNode.closest('[data-id]');
                }

                // 如果是文本节点（常见情况），从其父元素开始找
                if (startNode.nodeType === Node.TEXT_NODE && startNode.parentElement) {
                return startNode.parentElement.closest('[data-id]');
                }

                return null;
            },


        };

        // AST节点类
        class ASTNode {
            constructor({ id, styleType, type, content, indentLevel = 0 }) {
                this.id = id;
                this.type = type;
                this.styleType = styleType; // 样式类型
                this.content = content;
                this.indentLevel = indentLevel;
                this.children = [];
                this.continueChildren = [];
                this.parent = null;
            }
            
            // 添加子节点
            addChild(node) {
                node.parent = this;
                this.children.push(node);
            }
            
            // 在某个位置插入子节点
            InserChildrentNode(node, index) {
                node.parent = this;
                if (index < 0 || index > this.children.length) {
                    throw new Error('Index out of bounds');
                }
                this.children.splice(index, 0, node);
            }
            
            // 添加继续节点
            addContinue(node) {
                node.parent = this;
                this.continueChildren.push(node);
            }
            
            // 在某个位置插入继续节点
            InsertContinueNode(node, index) {
                node.parent = this;
                if (index < 0 || index > this.continueChildren.length) {
                    throw new Error('Index out of bounds');
                }
                this.continueChildren.splice(index, 0, node);
            }
            
            // 移除节点
            remove() {
                if (this.parent) {
                    const parentChildren = this.parent.children;
                    const parentContinues = this.parent.continueChildren;
                    
                    let index = parentChildren.indexOf(this);
                    if (index > -1) {
                        parentChildren.splice(index, 1);
                    } else {
                        index = parentContinues.indexOf(this);
                        if (index > -1) {
                            parentContinues.splice(index, 1);
                        }
                    }
                }
            }
            
            // 转换为JSON
            toJSON() {
                const result = {
                    id: this.id,
                    type: this.type,
                    styleType: this.styleType,
                    content: this.content,
                    indentLevel: this.indentLevel
                };

                if (this.continueChildren.length > 0) {
                    result.continueChildren = this.continueChildren.map(child => child.toJSON());
                }
                
                if (this.children.length > 0) {
                    result.children = this.children.map(child => child.toJSON());
                }
                
                return result;
            }
        }

        // AST管理器
        class ASTManager {
            constructor() {
                this.root = [];
                this.nodeMap = new Map();
                this.indentStack = [];
            }
            
            clearAll(){
                this.clearNodeMap();
                this.clearRoot();
                this.clearIndentStack();
            }
            
            // 清空AST
            clearNodeMap() {
                this.nodeMap.clear();
            }
            
            clearRoot() {
                this.root = [];
            }
            
            clearIndentStack() {
                this.indentStack = [];
                this.indentStack.length = 0;
            }
            
            // 创建节点
            createNode({ id, styleType, type, content, indentLevel }) {
                const node = new ASTNode({ id, styleType, type, content, indentLevel });
                this.nodeMap.set(id, node);
                return node;
            }
            
            // tab 缩进或反缩进 模式下，向 AST 中插入节点
            InsertNodeByTab(node){
                const { id, styleType, type, content, indentLevel } = node;
                if (type === NODE_TYPES.CONTINUE) {
                    this.handleContinueNodeByTab(indentLevel, content, id);
                } else if( type === NODE_TYPES.PARAGRAPH){
                    this.handleParagraphNodeByTab(NODE_TYPES.PARAGRAPH, NODE_TYPES.PARAGRAPH, indentLevel, content, id);
                } else if (type === NODE_TYPES.BLOCK) {
                    this.handleBlockNodeByTab(indentLevel, content, id);
                }
            }
            
            convertNodeType(id, newType, newStyleType, content) {
                const node = this.nodeMap.get(id);
                if (!node) {
                    console.error(`Node with id ${id} not found`);
                    return false;
                }
                
                // 更新节点类型和样式
                node.type = newType;
                node.styleType = newStyleType;
                node.content = content;
                
                // 更新缩进级别
                node.indentLevel = Utils.getIndentLevel(content);
                
                // 更新节点在 AST 中的位置
                // this.updateNodeInAST(node);
                
                return true;
            }
            
            // 使用 enter 键插入节点
            enterInsertNode(e, frontAstNodeId, toInsertLineId, initialContent, indentLevel, frontLineAstNodeType) {
                // const toInsertLineId = toInsertLine.dataset.id
                if ((e.shiftKey && frontLineAstNodeType === NODE_TYPES.BLOCK) || frontLineAstNodeType === NODE_TYPES.CONTINUE) {
                    // 在 AST 中插入 continue 节点
                    this.enterInsertAstContinueNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel});
                } else if (frontLineAstNodeType === NODE_TYPES.PARAGRAPH) {
                    // 在 AST 中插入段落节点
                    this.enterInsertAstParagraphNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel});
                } else if(frontLineAstNodeType === NODE_TYPES.BLOCK) {
                    // ✅ 增量插入 AST
                    this.enterInsertAstBlockNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel});
                }
            }

            enterInsertAstContinueNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel}) {
                let continueIndex = 0;
                const frontAstNode = this.nodeMap.get(frontAstNodeId);
                // 如果当前输入 shift+enter 的行是 continue 节点，在 idmap获取其所属的父节点, 否则就是当前节点
                let parentAstNode = null;
                if (frontAstNode.type === NODE_TYPES.BLOCK){
                    parentAstNode = frontAstNode;
                } else {
                    parentAstNode = frontAstNode.parent;
                    if (!parentAstNode) {
                        console.error("parentAstNode, 当前行未找到对应的 AST 父节点");
                        return;
                    }
                }
                // 获取即将插入的 continue 节点在 parentAstNode.continueChildren 中的索引
                const toInsertIndex = parentAstNode.continueChildren.indexOf(frontAstNode) + 1;
                // }
                const node = this.createNode({
                    id: toInsertLineId,
                    styleType:NODE_TYPES.CONTINUE,
                    type:NODE_TYPES.CONTINUE,
                    content: initialContent,
                    indentLevel
                });
                parentAstNode.InsertContinueNode(node, toInsertIndex);
            }

            enterInsertAstParagraphNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel, styleType, type}) {
                if (!frontAstNodeId) {
                    console.error("frontAstNodeId, 当前行未找到对应的 AST 节点");
                    return;
                }
                const node = this.createNode({
                    id: toInsertLineId,
                    styleType: styleType || NODE_TYPES.PARAGRAPH,
                    type: type || NODE_TYPES.PARAGRAPH,
                    content: initialContent,
                    indentLevel}
                )
                // 获取前面行的Ast节点
                const frontAstNode = this.nodeMap.get(frontAstNodeId);
                // 获取在 astRoot 中的索引
                const toInsertAstRootIndex = this.root.findIndex(n => n.id === frontAstNode.id);
                // 如果没有找到索引，说明当前节点是根节点
                if (toInsertAstRootIndex ===  -1) {
                    console.warn("当前 AST 节点未找到在 astRoot 中的索引");
                    return;
                }
                // 在 astRoot 中插入节点
                this.root.splice(toInsertAstRootIndex + 1, 0, node);
            }

            enterInsertAstBlockNode({frontAstNodeId, toInsertLineId, initialContent, indentLevel}) {
                // 获取当前Ast节点
                const frontAstNode = this.nodeMap.get(frontAstNodeId);
                if (!frontAstNode) {
                    console.error("frontAstNode, 当前行未找到对应的 AST 节点");
                    return;
                }
                const node = this.createNode({
                    id: toInsertLineId,
                    styleType: NODE_TYPES.BLOCK,
                    type: NODE_TYPES.BLOCK,
                    content: initialContent,
                    indentLevel}
                )

                let tempChildren = frontAstNode.children || [];
                let tempContinueChildren = frontAstNode.continueChildren || [];
                if (tempChildren.length > 0 || tempContinueChildren.length > 0) {
                    // 将 tempChildren 和 tempContinueChildren 中的节点作为toInsertLineId 对应节点的 children 与 continueChildren, 并且要调整 children 与 continueChildren 中每个节点的 parent
                    node.children = tempChildren;
                    node.continueChildren = tempContinueChildren;
                    // 更新每个子节点的 parent
                    tempChildren.forEach(child => {
                        child.parent = node;
                    });
                    tempContinueChildren.forEach(child => {
                        child.parent = node;
                    });
                    
                    // 删除 frontAstNode 中的 children 和 continueChildren
                    frontAstNode.children = [];
                    frontAstNode.continueChildren = [];
                } 

                const astNodeParent = frontAstNode?.parent;
                if (!astNodeParent) {
                    // 获取在 this.root 中的索引
                    const toInsertIndex = this.root.findIndex(n => n.id === frontAstNode.id);
                    if (toInsertIndex === -1) {
                        console.error("当前 Block AST 节点未找到在 astRoot 中的索引");
                        return;
                    }
                    // 在 astRoot 中插入节点
                    this.root.splice(toInsertIndex + 1, 0, node);
                } else {
                    // 获取 frontAstNode 在 astNodeParent.children 中的索引
                    const toInsertIndex = astNodeParent.children.indexOf(frontAstNode)
                    astNodeParent.InserChildrentNode(node, toInsertIndex + 1);
                }
            }
            
            // 插入节点
            insertNode(content, id) {
                const indentLevel = Utils.getIndentLevel(content);
                const blockLevel = Utils.isBlockLine(content);
                const continueLevel = Utils.continueLineLevel(content);
                const spaceIndent = Utils.hasSpaceIndent(content);
                
                let type = NODE_TYPES.PARAGRAPH;
                
                // 判断节点类型
                if (blockLevel !== null) {
                    type = NODE_TYPES.BLOCK;
                } else if (this.isContinueLine(indentLevel, continueLevel, spaceIndent)) {
                    type = NODE_TYPES.CONTINUE;
                }
                
                const node = this.createNode({ id, styleType: type, type, content, indentLevel });
                
                // 根据类型处理节点
                switch (type) {
                    case NODE_TYPES.BLOCK:
                        this.handleBlockNode(node, indentLevel);
                        break;
                    case NODE_TYPES.CONTINUE:
                        this.handleContinueNode(node, indentLevel);
                        break;
                    case NODE_TYPES.PARAGRAPH:
                        this.handleParagraphNode(node);
                        break;
                }
                
                return node;
            }
            
            // 判断是否为继续行
            isContinueLine(indentLevel, continueLevel, spaceIndent) {
                const lastStackNode = this.indentStack[this.indentStack.length - 1];
                return (continueLevel === this.indentStack.length - 1) || 
                       (lastStackNode && spaceIndent > 0);
            }

            // 处理 块节点 在 tab  缩进或反缩进 模式下
            handleBlockNodeByTab(indentLevel, content, id) {
                const node = this.createNode({ id, styleType: NODE_TYPES.BLOCK, type: NODE_TYPES.BLOCK, content, indentLevel });
                const parent = indentLevel > 0 ? this.indentStack[indentLevel - 1] : null;
                const closeParent = this.indentStack.length > 0 ? this.indentStack[this.indentStack.length - 1] : null

                if (parent) {
                    parent.addChild(node)
                    this.indentStack[indentLevel] = node;
                    this.indentStack.length = indentLevel + 1;
                } else if (closeParent !== null && closeParent.type === NODE_TYPES.BLOCK && indentLevel - 1 > closeParent.indentLevel) {
                    node.styleType = NODE_TYPES.CONTINUE
                    closeParent.addContinue(node);
                } else if (indentLevel === 0){
                    this.root.push(node);
                    this.indentStack[0] = node;
                    this.indentStack.length = 1;
                } else {
                    console.warn("无法找到 block 节点的父节点，请检查缩进格式");
                    // 如果没有找到父节点，可能是因为缩进格式不正确，直接插入一个段落节点
                    this.handleParagraphNodeByTab(NODE_TYPES.BLOCK, NODE_TYPES.PARAGRAPH, indentLevel, content,  id);
                }
            }
            
            // 处理块节点
            handleBlockNode(node, indentLevel) {
                const parent = indentLevel > 0 ? this.indentStack[indentLevel - 1] : null;
                
                if (parent) {
                    parent.addChild(node);
                } else if (indentLevel === 0) {
                    this.root.push(node);
                } else {
                    // 处理缩进错误
                    this.root.push(node);
                    console.warn('缩进级别不匹配，已插入到根级别');
                }
                
                // 更新缩进栈
                this.indentStack[indentLevel] = node;
                this.indentStack.length = indentLevel + 1;
            }
            
            // 处理继续节点
            handleContinueNode(node, indentLevel) {
                const parent = this.indentStack[indentLevel];
                
                if (parent && parent.type === NODE_TYPES.BLOCK) {
                    parent.addContinue(node);
                } else {
                    // 转为段落节点
                    node.type = NODE_TYPES.PARAGRAPH;
                    this.handleParagraphNode(node);
                }
            }

            handleContinueNodeByTab(indentLevel, content, id) {
                const parent = this.indentStack[indentLevel];
                const closeParent = this.indentStack.length > 0 ? this.indentStack[this.indentStack.length - 1] : null;
                const spaceCount = closeParent !== null ? Utils.hasSpaceIndent(content) : null;
                // 如果是 continue 节点，且上一个节点是 block 节点，
                // 且 continueIndent 大于 0 或者 spaceCount 大于 0
                // 则将 continue 节点添加到 block 节点的 continueChildren 中
                if (closeParent && closeParent.type === NODE_TYPES.BLOCK && (indentLevel > 0 || spaceCount > 0) ) {
                    // 创建 Node 的过程中，也会更新 nodeMap
                    const node = this.createNode({ id, styleType: NODE_TYPES.CONTINUE, type: NODE_TYPES.CONTINUE, content, indentLevel });
                    closeParent.addContinue(node);
                } else {
                    // 如果没有找到父节点，可能是因为缩进格式不正确，直接插入一个段落节点
                    this.handleParagraphNodeByTab(NODE_TYPES.PARAGRAPH, NODE_TYPES.PARAGRAPH, indentLevel, content, id);
                    console.warn("无法找到 continue 节点的父节点，请检查缩进格式");
                    return;
                }
            }
            
            // 处理段落节点
            handleParagraphNode(node) {
                this.root.push(node);
                this.indentStack = [];
            }
            
            handleParagraphNodeByTab(type, styleType, indentLevel, content, id) {
                // 创建 Node 的过程中，也会更新 nodeMap
                const node = this.createNode({ id, styleType, type, content, indentLevel });
                this.root.push(node);
                this.indentStack = [];
            }
            
            // 更新节点内容
            updateNodeContent(id, content) {
                const node = this.nodeMap.get(id);
                if (node) {
                    node.content = content;
                }
            }
            
            // 删除节点
            deleteNode(id) {
                const node = this.nodeMap.get(id);
                if (node) {
                    node.remove();
                    this.nodeMap.delete(id);
                }
            }
            
            // 重建AST
            rebuild() {
                this.clearNodeMap();
                this.clearIndentStack();
                
                // 获取扁平化的节点列表
                const flatNodes = this.flattenNodes(this.root);
                // 清空根节点
                this.clearRoot();
                // 重新构建
                flatNodes.forEach(node => {
                    this.InsertNodeByTab(node);
                });
            }
            
            // 重建AST
            rebuildWhenMutationsLine(editor) {
                
                // 获取扁平化的节点列表
                const flatNodes = this.flattenNodesFromEditor(editor);
                // // 清空节点映射
                // this.clearNodeMap();
                // // 清空根节点
                // this.clearRoot();
                // this.clearIndentStack();
                this.clearAll();
                // 重新构建
                flatNodes.forEach(node => {
                    this.insertNode(node.content, node.id);
                });
            }

            // 扁平化节点
            flattenNodes(nodes) {
                const result = [];
                
                function flatten(nodeList) {
                    nodeList.forEach(node => {
                        result.push(node);
                        if (node.continueChildren.length > 0) {
                            flatten(node.continueChildren);
                        }
                        if (node.children.length > 0) {
                            flatten(node.children);
                        }
                    });
                }
                
                flatten(nodes);
                return result;
            }

            // 通过 editor 按顺序获取所有的 line，通过 editor children 的方式获取
            flattenNodesFromEditor(editor) {
                const lines = Array.from(editor.children);
                // 通过 nodeMap 获取 AST 节点
                return lines.map(line => {
                    const id = line.dataset.id;
                    const node = this.nodeMap.get(id);
                    if (!node) {
                        // console.warn(`未找到对应的 AST 节点: ${id}`);
                        return this.createNode({
                            id,
                            styleType: null,
                            type: null,
                            content: line.textContent || '',
                            indentLevel: null
                        });
                    }
                    return node

                });
            }
            
            // 渲染AST
            renderAST() {
                const output = document.getElementById('astOutput');
                const stats = document.getElementById('stats');
                
                const astData = this.root.map(node => node.toJSON());
                output.textContent = JSON.stringify(astData, null, 2);
                
                // 显示统计信息
                const totalNodes = this.nodeMap.size;
                const blockNodes = Array.from(this.nodeMap.values()).filter(n => n.type === NODE_TYPES.BLOCK).length;
                const continueNodes = Array.from(this.nodeMap.values()).filter(n => n.type === NODE_TYPES.CONTINUE).length;
                const paragraphNodes = Array.from(this.nodeMap.values()).filter(n => n.type === NODE_TYPES.PARAGRAPH).length;
                
                stats.innerHTML = `
                    <strong>统计信息:</strong>
                    总节点: ${totalNodes} | 
                    块节点: ${blockNodes} | 
                    继续节点: ${continueNodes} | 
                    段落节点: ${paragraphNodes}
                `;
            }
            
            // 获取节点
            getNode(id) {
                return this.nodeMap.get(id);
            }
        }

        // 编辑器管理器
        class EditorManager {
            constructor(editorElement, astManager) {
                this.editor = editorElement;
                this.astManager = astManager;
                this.setupEventListeners();
            }
            
            // 设置事件监听器
            setupEventListeners() {
                this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
                this.editor.addEventListener('input', Utils.debounce(this.handleInput.bind(this), 200));
            }
            
            // 处理键盘事件
            handleKeydown(e) {
                switch (e.key) {
                    case 'Enter':
                        this.handleEnter(e);
                        break;
                    case 'Tab':
                        this.handleTab(e);
                        break;
                }
            }
            
            // 处理回车键
            handleEnter(e) {
                e.preventDefault();
                
                const currentLine = this.getCurrentLine();
                if (!currentLine) return;
                
                const currentContent = currentLine.textContent || '';
                const currentNode = this.astManager.getNode(currentLine.dataset.id);
                
                if (!currentNode) return;
                
                const indentLevel = Utils.getIndentLevel(currentContent);
                const toInsertLineId = Utils.generateId();
                
                // 确定新行的初始内容
                let initialContent = INDENT_CHAR.repeat(indentLevel);
                
                if ((e.shiftKey && currentNode.type === NODE_TYPES.BLOCK) || currentNode.type === NODE_TYPES.CONTINUE) {
                    initialContent += CONTINUE_PREFIX;
                } else if (currentNode.type === NODE_TYPES.PARAGRAPH) {
                    // 段落行保持相同缩进
                } else {
                    initialContent += BLOCK_PREFIX;
                }
                
                // 创建新行
                const newLine = this.createLine(initialContent, toInsertLineId);
                this.insertLineAfter(currentLine, newLine);
                Utils.setCaretToEnd(newLine);
                
                // 更新AST
                const frontAstNodeId = currentNode.id;
                this.astManager.enterInsertNode(e, frontAstNodeId, toInsertLineId, initialContent, indentLevel, 
                    currentNode.type);
                this.astManager.renderAST();
            }
            
            // 处理Tab键
            handleTab(e) {
                e.preventDefault();
                const isShift = e.shiftKey;
                const selection = window.getSelection();
                const range = selection.getRangeAt(0);

                // 获取选中所有行（已排序）
                const lines = this.getSelectedLines();
                if (!lines.length) return;

                const isSingleLine = lines.length === 1;

                // 缓存光标信息
                const anchorOffset = range.startOffset;
                const focusOffset = range.endOffset;

                // 缓存原始的锚点和焦点行
                const originalAnchorLine = lines[0];
                const originalFocusLine = lines[lines.length - 1];

                // 执行缩进逻辑
                lines.forEach(line => {
                    const node = this.astManager.getNode(line.dataset.id);
                    if (!node) return;

                    let text = line.textContent;
                    if (isShift) {
                        if (text.startsWith(INDENT_CHAR)) {
                            text = text.slice(1);
                            node.indentLevel = Math.max(0, node.indentLevel - 1);
                        }
                    } else {
                        text = INDENT_CHAR + text;
                        node.indentLevel += 1;
                    }

                    line.textContent = text;
                    node.content = text;

                    if (node.indentLevel > 0 && node.type === NODE_TYPES.PARAGRAPH) {
                        const continueLevel = Utils.continueLineLevel(text);
                        node.type = continueLevel !== null ? NODE_TYPES.CONTINUE : NODE_TYPES.BLOCK;
                    }
                });

                // 新的选区恢复
                const newAnchorNode = originalAnchorLine.firstChild;
                const newFocusNode = originalFocusLine.firstChild;

                if (newAnchorNode && newFocusNode) {
                    const newRange = document.createRange();

                    if (isSingleLine) {
                        // 单行：光标随着缩进移动
                        const delta = isShift ? -1 : 1;
                        const adjustedAnchorOffset = Math.max(0, anchorOffset + delta);
                        const adjustedFocusOffset = Math.max(0, focusOffset + delta);

                        newRange.setStart(newAnchorNode, Math.min(adjustedAnchorOffset, newAnchorNode.length));
                        newRange.setEnd(newFocusNode, Math.min(adjustedFocusOffset, newFocusNode.length));
                    } else {
                        // 多行：保持整块选区，不要偏移
                        newRange.setStart(newAnchorNode, 0);
                        newRange.setEnd(newFocusNode, newFocusNode.length);
                    }

                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }

                this.editor.focus();
                this.astManager.rebuild();
                this.astManager.renderAST();

            }

            // 处理输入事件 - 增强版，支持自动转换为块节点
            handleInput(e) {
                const line = this.getCurrentLine();
                if (!line) return;
                
                const id = line.dataset.id;
                const content = line.textContent || '';
                const currentNode = this.astManager.getNode(id);
                
                if (!currentNode) return;
                
                // 检查是否需要转换节点类型
                this.checkAndConvertNodeType(line, currentNode, content);
                
                // 更新AST中的节点内容
                this.astManager.updateNodeContent(id, content);
                this.astManager.renderAST();
            }
            
            // 检查并转换节点类型
            checkAndConvertNodeType(line, currentNode, content) {
                const indentLevel = Utils.getIndentLevel(content);
                const isBlockLine = Utils.isBlockLine(content) !== null;
                const isContinueLine = Utils.isContinueLine(content) !== null && !isBlockLine;
                
                let newType = NODE_TYPES.PARAGRAPH;
                let newStyleType = NODE_TYPES.PARAGRAPH;
                
                // 根据内容确定新的节点类型
                if (isBlockLine) {
                    newType = NODE_TYPES.BLOCK;
                    newStyleType = NODE_TYPES.BLOCK;
                } else if (isContinueLine && this.hasBlockParent(currentNode)) {
                    newType = NODE_TYPES.CONTINUE;
                    newStyleType = NODE_TYPES.CONTINUE;
                } else {
                    newType = NODE_TYPES.PARAGRAPH;
                    newStyleType = NODE_TYPES.PARAGRAPH;
                }
                
                // 如果类型发生变化，进行转换
                if (currentNode.type !== newType) {
                    console.log(`转换节点类型: ${currentNode.type} -> ${newType}`, { content, indentLevel });
                    
                    // 转换AST中的节点类型
                    const success = this.astManager.convertNodeType(currentNode.id, newType, newStyleType, content);
                    
                    if (success) {
                        // 更新DOM元素的样式类
                        this.updateLineStyle(line, newStyleType);
                        
                        // 如果转换成功，重建AST以确保结构正确
                        this.astManager.rebuild();
                    }
                } else {
                    // 即使类型没有变化，也要确保样式类正确
                    this.updateLineStyle(line, newStyleType);
                }
            }
            
            // 检查是否有块节点父级
            hasBlockParent(currentNode) {
                return currentNode && currentNode.parent?.type === NODE_TYPES.BLOCK;
            }
            
            // 更新行的样式类
            updateLineStyle(line, styleType) {
                // 移除所有样式类
                line.classList.remove('block', 'continue', 'paragraph');
                
                // 添加新的样式类
                switch (styleType) {
                    case NODE_TYPES.BLOCK:
                        line.classList.add('block');
                        break;
                    case NODE_TYPES.CONTINUE:
                        line.classList.add('continue');
                        break;
                    case NODE_TYPES.PARAGRAPH:
                        line.classList.add('paragraph');
                        break;
                }
            }
            
            // 创建行元素
            createLine(content = '', id = Utils.generateId()) {
                const div = document.createElement('div');
                div.className = 'line';
                // div.contentEditable = 'true';
                div.textContent = content;
                div.dataset.id = id;
                
                // 根据内容添加样式类
                if (Utils.isBlockLine(content) !== null) {
                    div.classList.add('block');
                } else if (Utils.isContinueLine(content) !== null) {
                    div.classList.add('continue');
                } else {
                    div.classList.add('paragraph');
                }
                return div;
            }
            
            // 在指定行后插入新行
            insertLineAfter(currentLine, newLine) {
                const nextLine = currentLine.nextSibling;
                if (nextLine) {
                    this.editor.insertBefore(newLine, nextLine);
                } else {
                    this.editor.appendChild(newLine);
                }
            }
            
            // 获取当前行
            getCurrentLine() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return null;
                
                let node = selection.anchorNode;
                if (node.nodeType === 3) node = node.parentNode;
                
                while (node && node !== this.editor && !node.classList.contains('line')) {
                    node = node.parentNode;
                }
                // 没有必要返回 index
                // Array.from(editor.children).indexOf(node);
                return (node && node !== this.editor) ? node : null;
            }
            
            // 获取选中的行
            // getSelectedLines() {
            //     const selection = window.getSelection();
            //     const range = selection.getRangeAt(0);
                
            //     return Array.from(this.editor.children).filter(line => {
            //         const lineRect = line.getBoundingClientRect();
            //         const rangeRect = range.getBoundingClientRect();
            //         return lineRect.bottom > rangeRect.top && lineRect.top < rangeRect.bottom;
            //     });
            // }

            // 获取选中的行（支持光标和多行选中）
            getSelectedLines() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return [];

                const range = selection.getRangeAt(0);

                // 如果是折叠选区（光标）
                if (range.collapsed) {
                    // 光标所在的 DOM 节点
                    let node = range.startContainer;
                    // 如果光标落在文本节点里，拿它的父元素
                    if (node.nodeType === Node.TEXT_NODE) {
                        node = node.parentElement;
                    }
                    // 找到属于 editor 的直接子元素（即一行）
                    while (node && node.parentElement !== this.editor) {
                        node = node.parentElement;
                    }
                    return node ? [node] : [];
                }

                // 如果是非折叠选区（有选中文字）
                const rangeRect = range.getBoundingClientRect();
                return Array.from(this.editor.children).filter(line => {
                    const lineRect = line.getBoundingClientRect();
                    return lineRect.bottom > rangeRect.top && lineRect.top < rangeRect.bottom;
                });
            }

            
            // 清空编辑器
            clear() {
                this.editor.innerHTML = '';
                this.astManager.clearAll();
                this.astManager.renderAST();
            }
            // 初始化编辑器，创建空白行
            initEditor() {
                this.clear();
                const id = Utils.generateId();
                const content = "";
                const lineElement = this.createLine(content, id);
                this.editor.appendChild(lineElement);
                this.astManager.insertNode(content, id);
                this.astManager.renderAST();
            }
            
            // 加载示例内容
            loadSample() {
                const sampleLines = [
                    '- 项目管理',
                    '\t- 任务分配',
                    '\t\t- 开发任务',
                    '\t\t- 测试任务',
                    '\t- 进度跟踪',
                    '\t  定期检查项目进度',
                    '\t  及时调整计划',
                    '- 代码优化',
                    '\t- 性能优化',
                    '\t- 代码重构',
                    '这是一个普通段落',
                    '这是另一个段落'
                ];
                
                this.clear();
                
                sampleLines.forEach(content => {
                    const id = Utils.generateId();
                    const lineElement = this.createLine(content, id);
                    this.editor.appendChild(lineElement);
                    this.astManager.insertNode(content, id);
                });
                
                this.astManager.renderAST();
            }
        }

        // 初始化应用
        const editor = document.getElementById('editor');
        const astManager = new ASTManager();
        const editorManager = new EditorManager(editor, astManager);

        // 创建 observer 实例
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.removedNodes.length > 0) {
                    console.log('⚠️ 某些 .line 被删除:', mutation.removedNodes);
                    // 从 AST 中删除对应的节点
                    astManager.rebuildWhenMutationsLine(editor);
                    astManager.renderAST();
                } else if (mutation.addedNodes.length > 0 && isUndoing === true) {
                    console.log('🔄 某些 .line 被添加:', mutation.addedNodes);
                    // 重新构建 AST
                    astManager.rebuildWhenMutationsLine(editor);
                    astManager.renderAST();
                }

            });
        });

        // 开始监听 editor 内部子节点的增删
        observer.observe(editor, {
            childList: true,      // 监听子元素变化
            subtree: false        // 不递归监听子节点的子节点
        });

        let isUndoing = false;

        // 监听 beforeinput 来捕捉是否是撤销操作
        editor.addEventListener('beforeinput', (event) => {
            if (event.inputType === 'historyUndo') {
                isUndoing = true;
                // 延迟清除标志，避免错过 observer 的异步触发
                setTimeout(() => {
                    isUndoing = false;
                }, 50);
            }
        });

        // 加载示例内容
        editorManager.loadSample();
    </script>
</body>
</html>