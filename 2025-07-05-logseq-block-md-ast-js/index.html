<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>增量更新 AST 编辑器</title>
  <style>
    body { font-family: monospace; padding: 1em; }
    #editor {
      border: 1px solid #ccc;
      padding: 8px;
      width: 600px;
      height: 300px;
      overflow-y: auto;
      white-space: pre-wrap; /* 保留换行，但更灵活 */
      tab-size: 4; /* 设置 Tab 为 4 个空格的宽度 */
    }
    .line {
      outline: none;
      min-height: 1.2em;
    }
    .line:empty::before {
      content: ""; /* 移除 \u200B，设置为空字符串 */
      display: inline-block; /* 确保空行有高度 */
      min-height: 1.2em; /* 保持行高 */
    }
    pre {
      background: #f9f9f9;
      padding: 1em;
    }
  </style>
</head>
<body>

<h2>增量 AST 编辑器</h2>
<div id="editor" contenteditable="true" tabindex="0" role="textbox" spellcheck="false"></div>
<button onclick="renderAST()">输出 AST</button>

<h3>AST 输出</h3>
<pre id="astOutput"></pre>

<script type="module">
  const editor = document.getElementById("editor");
  const astOutput = document.getElementById("astOutput");

  let astRoot = [];
  const idMap = new Map();     // id => { node, parent }
  let indentStack = [];      // 层级 => 最近节点

  // 创建一行带唯一 ID 的 DOM
  function createLine(text = "", id = crypto.randomUUID()) {
    const div = document.createElement("div");
    div.className = "line";
    div.contentEditable = "true";
    div.textContent = text;
    div.dataset.id = id;
    return div;
  }
  // 初始化内容（演示用）
  function initEditor() {
    // const lines = [
    //   "- 示例 Block",
    //   "\t- 子项 1",
    //   "\t\t- 子子项",
    //   "\t- 子项 2",
    //   "\t  子项 2 continue 1",
    //   "\t  子项 2 continue 2",
    //   "普通段落1",
    //   "- 第二个 Block",
    //   "\t- 子项 1",
    //   "\t  子项 1 continue 1",
    //   "\t- 子项 2",
    //   "普通段落2",
    //   "普通段落3",
    // ];
    const lines = [
      "- dsfuosfusof",
      "\t- fjdslfjslfjslfjlsd",
      "\t- sdjflsdfklsdfklsf",
      "\t22222",
      "\t\t- djljfslf",
      "\t\t- slfjlsfjlsfjlsfj",
      "\t\t- jfslfjslfjslf",
      "\t- 8888888",
      "\t\t- fjlsdfjlsfjklsfls",
      "\t\t- sdfjslfjlsfjslf",
      "\t- 5555555",
      "66666fjslfjlsfjslfjl",
      " djfsljflsdfjlsfjsl"
    ]
    console.log("initEditor", lines.length, "lines", lines)
    editor.innerHTML = "";
    astRoot = [];
    idMap.clear();
    indentStack.length = 0;

    lines.forEach((text, i) => {
      console.log("initEditor", i, text);
      const div = createLine(text);
      editor.appendChild(div);
      insertAstNodeAtByOrder(i, text, div.dataset.id); // 直接构建 AST
    });

    setCaretToEnd(editor.lastChild);
    renderAST();
  }

  function getIndentForLine(text) {
    const match = text.match(/^(\t*)- /);
    if (match === null) return null; // 如果没有匹配到，返回 null
    return match[1].length;
  }
  // 获取 continue 节点的缩进层级
  function getIndentForNoBlockLine(text) {
    // const match = text.match(/^(\t*) {2}/);
    // const match = text.match(/^(\t*)/);
    // (\t*) 后面不接 -
    const match = text.match(/^(\t*)(?!-)/);
    if (match === null) return null; // 如果没有匹配到，返回 null
    return (match[1].length); 
  }

  // get space indent for node
  function getSpaceIndentForLine(text) {
    // 匹配开头至少一个空格（不包括 tab 或其他空白字符）
    const match = text.match(/^( +)/);
    if (match === null) return null; // 没有匹配到空格
    return match[1].length;
  }



  function RandomInsertAstContinueNode(index, line, id, content, indentCount) {
    let continueIndex = 1;
    let currentIndex = index;
    let lineId = line.dataset.id;
    let currentAstNode = idMap.get(lineId).node;
    // 如果当前输入 shift+enter 的行是 continue 节点，在 idmap获取其所属的父节点, 否则就是当前节点
    const belongToAstNode = currentAstNode.lineContinue ? idMap.get(lineId).parent : currentAstNode;
    let baseNode = currentAstNode;

    // 获取即将插入的 continue 节点在 belongToAstNode.continueChildren 中的索引
    if (currentAstNode.lineContinue){
      continueIndex = belongToAstNode.continueChildren.indexOf(currentAstNode) + 1;
    }
    // indentCount 是 continueNode 所属 Node 在 editor的缩进层级
    // const continueNode = { id, content, indentCount , lineContinue: true };
    const continueNode = createAstNode({
      id,
      styleType:TextType.CONTINUE,
      type:TextType.CONTINUE,
      // content: content.trim(),
      content: content,
      indentCount
    });
    // continueIndex 是 continueNode 在 belongToAstNode.continueChildren 中的索引
    belongToAstNode.continueChildren.splice(continueIndex, 0, continueNode);
    idMap.set(id, { node:continueNode, parent:belongToAstNode });
  }

  function insertAstParagraphNodeAt(index, line, id, content, indentCount) {
    // index 是希望插入在当前行之后的在 editor 的位置
    // index -1 是当前在 editor 的位置
    const currentIndex = index - 1;
    
    // 获取当前Ast节点
    const currentAstNode = idMap.get(line.dataset.id)?.node;
    if (!currentAstNode) {
      console.error("currentAstNode, 当前行未找到对应的 AST 节点");
      return;
    }
    const node = createAstNode({
      id,
      styleType:TextType.PARAGRAPH,
      type:TextType.PARAGRAPH,
      content,
      indentCount}
    )

    // 获取在 astRoot 中的索引
    const astRootIndex = astRoot.findIndex(n => n.id === currentAstNode.id);
    if (astRootIndex === -1) {
      console.error("当前 AST 节点未找到在 astRoot 中的索引");
      return;
    }
    astRoot.splice(astRootIndex + 1, 0, node);
    idMap.set(id, { node, parent: null });
    
  }

  function randomInsertAstBlockNodeAt(index, line, id, content, indentCount) {
    // index 是希望插入在当前行之后的在 editor 的位置
    // index -1 是当前在 editor 的位置
    const currentIndex = index - 1;
    
    // 获取当前Ast节点
    const currentAstNode = idMap.get(line.dataset.id)?.node;
    if (!currentAstNode) {
      console.error("currentAstNode, 当前行未找到对应的 AST 节点");
      return;
    }
    const currentAstNodeParent = idMap.get(line.dataset.id)?.parent;
    const node = createAstNode({
      id,
      styleType:TextType.BLOCK,
      type:TextType.BLOCK,
      content,
      indentCount}
    )

    if (!currentAstNodeParent) {
      // 获取在 astRoot 中的索引
      const astRootIndex = astRoot.findIndex(n => n.id === currentAstNode.id);
      if (astRootIndex === -1) {
        console.error("当前 AST 节点未找到在 astRoot 中的索引");
        return;
      }
      astRoot.splice(astRootIndex + 1, 0, node);
      idMap.set(id, { node, parent: null });
    } else {
    // 获取 currentAstNode 在 currentAstNodeParent.children 中的索引
    const currentAstNodeIndex = currentAstNodeParent.children.indexOf(currentAstNode)
    currentAstNodeParent.children.splice(currentAstNodeIndex + 1, 0, node);
    idMap.set(id, { node, parent: currentAstNodeParent });
    }
  }

  function createAstNode({ id, type, styleType, content, indentCount}) {
    const base = {
      id,
      styleType,
      type,
      content: content,
      indentCount
    };
    if (type === TextType.BLOCK) {
      return { ...base, continueChildren: [], children: []};
    } else if (type === TextType.PARAGRAPH) {
      return { ...base };
    } else if (type === TextType.CONTINUE) {
      // continue 节点只需要标识 lineContinue
      return { ...base, "lineContinue": true };
    }
  }

  // 用于标识上次插入的节点类型
  // let lastWasParagraph = false; // 上次添加Paragraph段落标志
  const TextType = {
    PARAGRAPH: 'paragraph',
    BLOCK: 'block',
    CONTINUE: 'continue'
  };

  function insertAstNodeAtByOrder(index, content, id) {
    const indentCount = getIndentForLine(content)
    const noBlockIndentCount = indentCount === null ? getIndentForNoBlockLine(content) : null;
    const spaceCount = (indentCount === null && noBlockIndentCount === null) ? getSpaceIndentForLine(content) : null;

    if (isContinueLineByOrder(indentCount, noBlockIndentCount, spaceCount)) {
      return handleContinueNodeByOrder(noBlockIndentCount, content, id);
    }

    if (isParagraphByOrder(indentCount, noBlockIndentCount)) {
      return handleParagraphNodeByOrder(TextType.PARAGRAPH, TextType.PARAGRAPH, noBlockIndentCount, content, id);
    }

    return handleBlockNodeByOrder(indentCount, content, id);
  }

  // tab 或者 shift + tab 之后, 根据更新 indentCount 后的 astRoot 语法树，创建新的 astRoot
  // 通过节点的 type 来判断是 continue 还是 paragraph 还是 block
  // 通过 indentCount 来判断是哪个层级的节点
  // 可以不用遍历 editor.children，直接根据 indentCount 和 type 来更新 astRoot
  // 通过深度遍历原来的 astRoot，获得 flattened 的节点列表，然后根据 indentCount 和 type 来重新构建新的 astRoot
  function updateAstRootByOrder() {
    // let newAstRoot = [];
    idMap.clear();
    indentStack.length = 0;
    let flattenedAstNodes = [];

    // get flattened nodes
    function flattenAstNodes(nodes) {
      nodes.forEach(node => {
        flattenedAstNodes.push(node);
        if (node.continueChildren) {
          flattenAstNodes(node.continueChildren);
        }
        if (node.children) {
          flattenAstNodes(node.children);
        }
      });
    }
    // 遍历原来的 astRoot，获得 flattened 的节点列表
    flattenAstNodes(astRoot);
    astRoot = []; // 清空原来的 astRoot
    // 根据 indentCount 和 type 来重新构建新的 astRoot
    flattenedAstNodes.forEach(node => {
      const { id, styleType, type, content, indentCount } = node;
      if (type === TextType.CONTINUE) {
        handleContinueNodeByOrder(indentCount, content, id);
      } else if (type === TextType.PARAGRAPH) {
        handleParagraphNodeByOrder(TextType.PARAGRAPH, TextType.PARAGRAPH, indentCount, content, id);
      } else if (type === TextType.BLOCK) {
        handleBlockNodeByOrder(indentCount, content, id);
      }
    });
    // return newAstRoot;
  }

  function isContinueLineByOrder(indentCount, noBlockIndentCount, spaceCount) {
    // (indentStack.length !== 0 && spaceCount > 0) 表示 最后一行不是普通行，并且 当前判断的行有空格
    return indentCount === null && (noBlockIndentCount === indentStack.length - 1 || (indentStack.length !== 0 && spaceCount !== null && spaceCount > 0));
  }

  function isParagraphByOrder(indentCount, noBlockIndentCount) {
    return indentCount === null && (noBlockIndentCount !== indentStack.length - 1);
  }
 
  function handleContinueNodeByOrder(continueIndent, content, id) {
    const parent = indentStack[continueIndent]
    const closeParent = indentStack.length > 0 ? indentStack[indentStack.length - 1] : null;
    const spaceCount = closeParent !== null ? getSpaceIndentForLine(content) : null;
    if (closeParent && closeParent.type === TextType.BLOCK && (continueIndent > 0 || spaceCount > 0) ) {
      // 如果是 continue 节点，且上一个节点是 block 节点，且 continueIndent 大于 0
      // 则将 continue 节点添加到 block 节点的 continueChildren 中
      closeParent.continueChildren.push(createAstNode({
        id,
        styleType:TextType.CONTINUE,
        type:TextType.CONTINUE,
        content: content,
        indentCount: continueIndent
      }));
      idMap.set(id, { node: closeParent.continueChildren[closeParent.continueChildren.length - 1], parent: closeParent });
      return;
    } else {
      // 如果没有找到父节点，可能是因为缩进格式不正确，直接插入一个段落节点
      handleParagraphNodeByOrder(TextType.PARAGRAPH, TextType.PARAGRAPH, continueIndent, content, id);
      console.warn("无法找到 continue 节点的父节点，请检查缩进格式");
      return;
    }
    // if (!parent || !parent.continueChildren || parent.indentCount !== continueIndent) {
    //   console.warn("无法找到 continue 节点的父节点，请检查缩进格式");
    //   handleParagraphNodeByOrder(TextType.CONTINUE, TextType.PARAGRAPH, continueIndent, content, id);
    // } else {
    //   const node = createAstNode({
    //     id,
    //     styleType:TextType.CONTINUE,
    //     type:TextType.CONTINUE,
    //     content: content,
    //     indentCount: continueIndent}
    //   );
    //   parent.continueChildren.push(node);
    //   idMap.set(id, { node, parent });
    // }
  }
  
  function handleParagraphNodeByOrder(type, styleType, indentCount, content, id) {
    const node = createAstNode({
      id,
      styleType:styleType,
      type:type,
      content: content,
      indentCount: indentCount }
    );
    astRoot.push(node);
    idMap.set(id, { node, parent: null });
    indentStack = [];
  }

  function handleBlockNodeByOrder(indentCount, content, id) {
    let node = createAstNode({ 
      id, 
      styleType:TextType.BLOCK,
      type:TextType.BLOCK, 
      // content: content.replace(/^\s*- /, ""), 
      content: content, 
      indentCount }
    );

    const parent = indentCount > 0 ? indentStack[indentCount - 1] : null;
    const closeParent = indentStack.length > 0 ? indentStack[indentStack.length - 1] : null
    if (parent) {
      parent.children.push(node);
      idMap.set(id, { node, parent });
      indentStack[indentCount] = node;
      indentStack.length = indentCount + 1;
    } else if (closeParent !== null && closeParent.type === TextType.BLOCK && indentCount - 1 > closeParent.indentCount) {
      node.styleType = TextType.CONTINUE
      closeParent.continueChildren.push(node);
      idMap.set(id, { node, parent: closeParent });
    } else if (indentCount === 0){
      astRoot.push(node);
      idMap.set(id, { node, parent: null });
      indentStack[0] = node;
      indentStack.length = 1;
    } else {
      console.warn("无法找到 block 节点的父节点，请检查缩进格式");
      // 如果没有找到父节点，可能是因为缩进格式不正确，直接插入一个段落节点
      handleParagraphNodeByOrder(TextType.BLOCK, TextType.PARAGRAPH, indentCount, content,  id);
    }
  }
  
  function setCaretToEnd(node) {
    const range = document.createRange();
    const sel = window.getSelection();
    range.selectNodeContents(node);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function getCurrentLineIndex() {
    const sel = window.getSelection();
    if (!sel.rangeCount) return 0;
    let node = sel.anchorNode;
    if (node.nodeType === 3) node = node.parentNode;
    while (node && node !== editor && !node.classList.contains("line")) {
      node = node.parentNode;
    }
    if (!node || node === editor) return 0;
    return Array.from(editor.children).indexOf(node);
  }

  function getCurrentAstNode() {
    const sel = window.getSelection();
    if (!sel.rangeCount) return null;
    let node = sel.anchorNode;
    if (!node) return null;
    if (node.nodeType === 3) node = node.parentNode;
    while (node && node !== editor && !node.classList.contains("line")) {
      node = node.parentNode;
    }
    if (!node || node === editor) return null;
    const id = node.dataset.id;
    return idMap.get(id)?.node || null;
  }

  function renderAST() {
    astOutput.textContent = JSON.stringify(astRoot, null, 2);
  }

  function getInitialLineContent(
    {indentCount,
      isContinueLine=false, 
      isParagraphLine=false}={}) {
    // 把一个值转换为整数, 效率高
    const safeIndentCount = Math.max(0, indentCount | 0); 
    const baseIndent = "\t".repeat(safeIndentCount);
    if (isContinueLine) {
      return baseIndent + "  "; // continue 行的初始内容
    } else if (isParagraphLine) {
      return baseIndent; // 段落行的初始内容
    } else {
      return baseIndent + "- "; // block 行的初始内容
    }
  }
  function setupEditorSync(editor, idMap, renderAST, options = {}) {
    const debounceDelay = options.debounceDelay ?? 200;

    let debounceTimer = null;

    const handleInput = () => {
      // 防抖
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const sel = window.getSelection();
        if (!sel.rangeCount) return;

        let node = sel.anchorNode;
        if (node.nodeType === 3) node = node.parentNode;
        while (node && node !== editor && !node.classList.contains("line")) {
          node = node.parentNode;
        }
        if (!node || node === editor) return;

        const id = node.dataset.id;
        const astNode = idMap.get(id)?.node;
        if (!astNode) return;

        // 去除 block 标识，并且去除首尾的空白字符
        // astNode.content = node.textContent.replace(/^\s*-\s*/, "").trim();
        astNode.content = node.textContent;
        renderAST();
      }, debounceDelay);
    };

    editor.addEventListener("input", handleInput);

    // 提供解绑函数
    return () => {
      editor.removeEventListener("input", handleInput);
      clearTimeout(debounceTimer);
    };
  }

  // 监听 Enter 插入行 + 增量更新 AST
  editor.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();
    const index = getCurrentLineIndex();
    const line = editor.children[index];
    const text = line.textContent || "";
    const currentAstNodeType = idMap.get(line.dataset.id)?.node?.type;
    let indentCount = getIndentForLine(text);
    if (indentCount === null) {
      indentCount = getIndentForNoBlockLine(text);
    } 
    const newId = crypto.randomUUID();

    let editorInitialLineContent;
    if (e.shiftKey || currentAstNodeType === TextType.CONTINUE){
        editorInitialLineContent = getInitialLineContent({indentCount, isContinueLine:true}); // 新continue 行的初始内容
    } else if(currentAstNodeType === TextType.PARAGRAPH){
        editorInitialLineContent = getInitialLineContent({indentCount, isParagraphLine:true}); // 新段落行的初始内容
    } else if (currentAstNodeType === TextType.BLOCK) {
      // 如果是 block 行，继续使用当前行的缩进
      editorInitialLineContent = getInitialLineContent({indentCount}); // 新block行的初始内容
    }

    // 在 editor 中插入新行
    const newLine = createLine(editorInitialLineContent, newId);
    const next = line.nextSibling;
    if (next) editor.insertBefore(newLine, next);
    else editor.appendChild(newLine);
    setCaretToEnd(newLine);

    if (e.shiftKey || currentAstNodeType === TextType.CONTINUE) {
      // 在 AST 中插入 continue 节点
      RandomInsertAstContinueNode(
        index,
        line,
        newId,
        editorInitialLineContent,
        indentCount,
      );
    } else if (currentAstNodeType === TextType.PARAGRAPH) {
      // 在 AST 中插入段落节点
      insertAstParagraphNodeAt(index + 1, line, newId, editorInitialLineContent, indentCount);
    } else if(currentAstNodeType === TextType.BLOCK) {
      // ✅ 增量插入 AST
      randomInsertAstBlockNodeAt(index + 1, line, newId, editorInitialLineContent, indentCount);
    }
    renderAST(); // 展示 AST
  });

  editor.addEventListener("keydown", (e) => {
    if (e.key !== "Tab") return;

    e.preventDefault();

    const isShift = e.shiftKey;
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);

    // 收集所有选中的行元素
    const lines = Array.from(editor.children).filter(line => {
      const rect = line.getBoundingClientRect();
      const selRect = range.getBoundingClientRect();
      return rect.bottom > selRect.top && rect.top < selRect.bottom;
    });

    lines.forEach(line => {
      const text = line.textContent || "";
      let id = line.dataset.id;
      const astNodeInfo = idMap.get(id);
      if (!astNodeInfo) return;

      const astNode = astNodeInfo.node;

      // 计算新缩进
      let newIndent = astNode.indentCount + (isShift ? -1 : 1);
      if (newIndent < 0) newIndent = 0;

      // 更新 DOM
      if (isShift) {
        if (line.textContent.startsWith("\t")) {
          line.textContent = line.textContent.replace(/^\t/, "");
        }
      } else {
        line.textContent = "\t" + line.textContent;
      }

      // 更新 AST 节点 type, 方便后续转到对应的 block 逻辑处理函数
      if (newIndent > 0 && astNode.type === TextType.PARAGRAPH) {
        const continueIndent = getIndentForNoBlockLine(line.textContent)
        if (continueIndent !== null){
          astNode.type = TextType.CONTINUE; // 如果之前是段落节点，变为 continue 节点
        } else {
          astNode.type = TextType.BLOCK; // 如果之前是段落节点，变为 block 节点
        }
      }
      astNode.indentCount = newIndent;
      astNode.content = line.textContent
    });

    // 重建 astRoot 
    updateAstRootByOrder();
    renderAST();
  });
  
  // 实时内容同步：用户在修改时同步 AST 节点的 content 字段
  // 启动编辑器监听
  setupEditorSync(editor, idMap, renderAST, { debounceDelay: 300 });
  
  // 初始化编辑器内容
  initEditor();
</script>

</body>
</html>
